import BST from '../ds/BST';
import BinaryTree from '../ds/BinaryTree';

/**
 * 4.2 - Minimal Tree
 * Given a sorted array of ascending unique integers
 * Create a binary search tree with minimal height
 * Time Complexity: O(N), Space Complexity O(N)
 */
export const minimalTree = (arr: number[]) => {
  // Edge Case - Short Array
  if (arr.length === 0) return null;
  if (arr.length === 1) return new BST(arr[0]);

  // Find middle index of array and generate new BST
  const centerIndex = Math.floor(arr.length / 2);
  const treeRoot = new BST(arr[centerIndex]);

  // Call minimalTree recursively on left and right parts of array
  if (centerIndex) treeRoot.left = minimalTree(arr.slice(0, centerIndex));
  if (centerIndex < arr.length - 1) treeRoot.right = minimalTree(arr.slice(centerIndex + 1));
  return treeRoot;
};

/**
 * 4.5 - Validate BST
 * Given a Binary Tree, check that it is a Binary Search Tree
 * Time Complexity O(N), Space Complexity O(1)
 */
export const isValidBST = (tree: BinaryTree<number>, max = Infinity, min = -Infinity): boolean => {
  // If a node exists on either side, it must be a valid BST
  if (tree.left) {
    // Nodes on left cannot have values greater than the root's value
    if (tree.left.value > tree.value) return false;
    if (tree.left.value > max || tree.left.value < min) return false;
    if (!isValidBST(tree.left, tree.value, min)) return false;
  }

  if (tree.right) {
    // Nodes on right cannot have values less than the root's value
    if (tree.right.value < tree.value) return false;
    if (tree.right.value > max || tree.right.value < min) return false;
    if (!isValidBST(tree.right, max, tree.value)) return false;
  }

  return true;
};

/**
 * 4.5 - BST Sequences
 * A binary search tree is generated by traversing an array and adding each value
 * Return all possible arrays that could have led to this sequence
 * Time Complexity O(N), Space Complexity O(1)
 */
